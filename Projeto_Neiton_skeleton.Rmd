---
title: "Acidentes de trânsito com e sem vítimas em Recife no ano 2019"
author: "Neiton Carvalho da Silva"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
bibliography: C:\\mestrado_UFRPE_Informatica_Aplicada_Neiton\\Computacao_para_Analise_de_Dados\\Atividades\\Projeto Neiton\\Neitonreferencia.bib    
---


```{r setup, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```



# Acidentes de trânsito com e sem vítimas em Recife no ano 2019

<p style="text-align: justify;">
Esta é uma atividade referente ao desenvolvimento de relatórios dinâmicos por meio do R Markdown para fazer uma análise dos dados referente a acidentes de trânsito com e sem vítimas em Recife no ano 2019, com objetivo de buscar alguma informação que possa agregar valor para sugerir alguma ação preventiva para evitar acidentes, logo salvando vidas de forma preventiva.
</p>

Fonte do Dataset: [Prefeitura do Recife: Acidentes de Trânsito com e sem vitimas 2019](http://dados.recife.pe.gov.br/dataset/acidentes-de-transito-com-e-sem-vitimas)

# 1. Introdução {.tabset}

## 1.1 Declaração do Problema

### 1.1.1 Problemática: acidentes no trânsito em Recife - 2019

<p style="text-align: justify;">
Salvar vidas de forma preventiva é a melhor opção no transito e a única forma de poder prevenir é realizando uma análise dos dados, neste projeto será apresentado um estudo data science detalhado referente aos acidentes de transito com e sem vítimas na população de Recife no período do ano de 2019. Estes dados foram gerados pela Empresa Municipal de Informática – EMPREL por meio de um dataset que é um conjunto de dados, está disponível no seguinte link:
[Dataset transito 2019](http://dados.recife.pe.gov.br/dataset/acidentes-de-transito-com-e-sem-vitimas)
</p>

## 1.2 Metodologia Desenvolvida

### 1.2.1 Investigação baseada em dados

A metodologia será por meio do processo com base nas evidências dos dados, seguindo as seguintes etapas:


![](C:\projeto_ufrpe\Processo_Salvar_vidas.png)

### 1.2.2 Entrada

<p style="text-align: justify;">
Vai seguir as seguintes etapas antes de começar o processo:
Baixar o dataset relacionado ao transito com e sem vítimas em Recife no ano 2019; [clique aqui para verificar](http://dados.recife.pe.gov.br/dataset/acidentes-de-transito-com-e-sem-vitimas)<br>
Fazer a limpeza dos dados, que é a padronização para poder começar a fazer a análise dos dados;<br>
</p>

### 1.2.3 Processo

<p style="text-align: justify;">
Aplicar técnicas de data science para encontrar alguma informação que possa agregar valor e que seja representativa da problemática, para poder gerar alguma informação que viabilize de forma representativa e convergendo a uma provável ação preventiva baseada nos dados do dataset.</p>

### 1.2.4 Saída

<p style="text-align: justify;">
Gerar gráficos e informações que possam agregar uma provável solução para evitar que aconteça mais algum acidente por meio de uma ação preventiva sugerida pelo autor baseada na análise dos dados.</p>


# 2. Pacotes Requeridos  {.tabset}

### 2.1 Explicação dos pacotes utilizados

<p style="text-align: justify;">
Segue uma tabela apresentando todos os pacotes utilizados neste projeto, como também a explicação de cada um. Procurando assim, deixar com melhor compreensão:
</p>

```{r echo = FALSE, results = 'asis'}

biblioteca <- c(
  "readr",
  "stringr",
  "dplyr",
  "tidyr",
  #"tidyverse",
  #"ggplot2",
  #"lattice",
  "tm",
 # "tm.lexicon.GeneralInquirer",
  "wordcloud",
  "SnowballC",
  "RColorBrewer",
  "syuzhet",
  "splitstackshape",
  "data.table",
  "anytime",
  "viridis",
  "formatR",
  "knitr"
)

explicacao <- c(
  "O objetivo do 'readr' é fornecer uma maneira rápida e amigável de ler dados retangulares (como 'csv', 'tsv' e 'fwf'). Ele foi projetado para analisar de maneira flexível muitos tipos de dados encontrados na natureza, enquanto ainda falha com facilidade quando os dados são alterados inesperadamente",
  "Um conjunto de invólucros consistente, simples e fácil de usar em torno do fantástico pacote 'stringi'. Todos os nomes de funções e argumentos (e posições) são consistentes, todas as funções lidam com 'NA' e vetores de comprimento zero da mesma maneira, e a saída de uma função é fácil de alimentar na entrada de outra",
  "É uma forma rápida e consistente para trabalhar na manipulação de dados, fornecendo um conjunto consistente de funções como verbos para facilitar, que ajudam a resolver os desafios mais comuns de manipulação de dados",
  "O pacote tidyr foi projetado especificamente para arrumar dados e funciona bem com pipelines de dados 'dplyr'",
#  "O 'tidyverse' é um conjunto de pacotes que funcionam em harmonia porque compartilham representações de dados comuns e design de 'API'. Este pacote foi projetado para facilitar a instalação e o carregamento de vários pacotes 'tidyverse' em uma única etapa",
#  "Um pacote para criar gráficos. Você fornece os dados, diz ao 'ggplot2' como mapear variáveis e gera os gráficos",
#  "Um poderoso e elegante sistema de visualização de dados de alto nível inspirado nos gráficos da Trellis, com ênfase em dados multivariados. A estrutura é suficiente para as necessidades gráficas típicas e também é flexível o suficiente para lidar com a maioria dos requisitos não padrão",
  "Este pacote é um framework para aplicativos de mineração de texto em R",
#  "É um complemento da função tm, caso o sistema der algum problema.",
  "Plotar uma nuvem de palavras",
  "Uma interface R para a biblioteca C 'libstemmer' que implementa o algoritmo de derivação de palavras de Porter para recolher palavras em uma raiz comum para ajudar na comparação de vocabulário. Os idiomas atualmente suportados são dinamarquês, holandês, inglês, finlandês, francês, alemão, húngaro, italiano, norueguês, português, romeno, russo, espanhol, sueco e turco",
  "Cria paletas de cores bonitas, especialmente para mapas temáticos",
  "Extrair sentimentos e arcos de plotagem derivados de sentimentos do texto usando três dicionários de sentimentos convenientemente empacotados para consumo pelos usuários R. O pacote também fornece um método para implementar o analisador de sentimentos coreNLP de Stanford.",
  "Este pacote serve para realizar uma amostragem estratificada",
  "Serve para a manipulação de tabelas",
  "Converta a entrada em qualquer caractere, número inteiro, numérico, fator ou tipo ordenado em objetos 'POSIXct' (ou 'Data'), usando um dos vários formatos predefinidos e confiando nos recursos do Boost para análise de data e hora.",
  "Este pacote serve para seleção de paleta de cores utilizada nos gráficos",
  "Fornece uma função tidy_source () para formatar o código-fonte R. Os espaços e recuos serão adicionados ao código automaticamente e os comentários serão preservados sob certas condições, para que o código R seja mais legível e organizado. Há também um aplicativo Shiny como interface do usuário neste pacote (consulte tidy_app ())",
  "Fornece uma ferramenta de uso geral para geração dinâmica de relatórios em R usando técnicas de programação alfabética."
  )

tb_pacote <- data.frame("biblioteca" = biblioteca,
                        "explicação" = explicacao,
                        stringsAsFactors = FALSE) 

library(knitr)
#kable(mtcars[1:5, ], caption = "A knitr kable.")

kable(tb_pacote, caption = "Tabela dos pacotes")
```



# 3. Preparação dos Dados {.tabset}

## 3.1 Importando dataset

### 3.1.1 Importação de forma automática

<p style="text-align: justify;">
A Importação do dataset é feito diretamento do site da prefeitura do Recife neste item foi necessário apresentar o data frame original pelo menos as 03 primeiras linhas para não ficar muito extenso.
</p>

```{r carregamento, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}

library(formatR)
library(dplyr)
library(tidyr)
library(knitr)

```


```{r impotacao_dataset, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}

#Criação da variável fileURL que recebe o endereço do Link do dataset
fileURL <- "http://dados.recife.pe.gov.br/dataset/44087d2d-73b5-4ab3-9bd8-78da7436eed1/resource/3531bafe-d47d-415e-b154-a881081ac76c/download/acidentes-2019.csv"

#Comando para realizar o download do arquivo e já direcionando o lugar que será salvo
download.file(fileURL, destfile =
                "C:\\projeto_ufrpe\\acidentes_2019.csv", method = "curl")

#Limpando a variável fileURL memória depois que não está sendo necessária
rm(fileURL)

#Verificando se o arquivo foi salvo no lugar correto
list.files("C:\\projeto_ufrpe\\")

#Apontar corretamente o caminho antes de começar à análise dos dados
setwd("C:/projeto_ufrpe")

#Criando o Dataset original batisado de df_transito após a importação
df_transito <- read.csv(file = "acidentes_2019.csv",
                        header = TRUE,#Primeira linha consiste no nome das colunas
                        strip.white = TRUE,#Remove espaços em branco antes e depois dos dados
                        na.strings = "",#Substitui as céluas vázias por NA
                        sep = ";")#Separador por ponto e virgula






```

### 3.1.2 Apresentação das 03 primeiras linhas do dataset importado:

```{r tabela, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
library(knitr)
#Apresentação das 03 primeiras linhas do dataset
kable(df_transito[1:3,], caption = "Tabela Importada")

```


O dataset df_transito original tem a seguinte dimensão:<br>
```{r dimensão, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
#Dimensão do data frame
dim(df_transito)
```
12062 - observações que quer dizer linhas<br>
41 - variáveis que pode ser chamada de campos ou colunas da tabela.<br>

### 3.1.3 Adicionando uma chave primária no dataset

<p style="text-align: justify;">
É importante logo adicionar uma chave primária para pode realizar os tratamentos dos dados no projeto.
</p>

```{r chave, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
#Adicionado uma chave primária ao dataset
id <- rownames(df_transito)
id <- as.numeric(id)
df_transito <- cbind(id=id, df_transito)
rm(id)
```

## 3.2 Explicação

### 3.2.1 Explicação de todos os campos do dataset

<p style="text-align: justify;">
Para poder realizar esta explicação foi necessário criar um data frame explicando cada variável com base nos dados apresentados, para que assim possa conseguir extrair informação.
<br>
Explicação de todos os campos originais conforme a importação
</p>

```{r explicacao_campos, echo = FALSE, results = 'asis', warning=FALSE, message=FALSE, error=FALSE}

#echo = FALSE, results = 'asis'
#Professor, estes comando funcionam na parte do Script, mas no R Markdown não conseguir fazer rodar.

#impotação da explicaçõa de todas as variaveis diretamente dropbox compartilhado.
tabela_campos <- read.csv(file = "https://www.dropbox.com/s/73j4vbvlfd6uw5y/tabela_campos.csv?dl=1", header = T, strip.white = T, na.strings = "", sep = ";", stringsAsFactors=FALSE, quote="" )


tabela_campos <- read.csv(file = "https://www.dropbox.com/s/73j4vbvlfd6uw5y/tabela_campos.csv?dl=1", 
                          header = T, 
                          strip.white = T, 
                          na.strings = "", 
                          sep = ";", 
                          stringsAsFactors=FALSE, 
                          quote="")

#Explicação de todas as variáveis que são os campos, informando o seu tipo e também uma explicação técnica de cada campo
View(tabela_campos)


#Como não está funcionando o R Markdonw, tive que implementar desta forma, para conseguir explicar finalmente
Campo <- c(
  "DATA",
  "hora",
  "natureza_acidente",
  "situacao",
  "bairro",
  "endereco",
  "numero",
  "detalhe_endereco_acidente",
  "complemento",
  "endereco_cruzamento",
  "numero_cruzamento",
  "referencia_cruzamento",
  "bairro_cruzamento",
  "num_semaforo",
  "sentido_via",
  "tipo",
  "descricao",
  "auto",
  "moto",
  "ciclom",
  "ciclista",
  "pedestre",
  "onibus",
  "caminhao",
  "viatura",
  "outros",
  "vitimas",
  "vitimasfatais",
  "acidente_verificado",
  "tempo_clima",
  "situacao_semaforo",
  "sinalizacao",
  "condicao_via",
  "conservacao_via",
  "ponto_controle",
  "situacao_placa",
  "velocidade_max_via",
  "mao_direcao",
  "divisao_via1",
  "divisao_via2",
  "divisao_via3"
)

Tipo <- c(
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "int",
  "chr",
  "chr",
  "chr",
  "int",
  "int",
  "int",
  "int",
  "int",
  "int",
  "int",
  "int",
  "int",
  "int",
  "int",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr",
  "chr"
)

Descricao <- c(
  "Data que aconteceu o acidente de trânsito",
  "Hora que foi registrado o acidente de trânsito",
  "Diz se o acidente teve vítima, ou não teve vítima, se foi com vítima fatal, se foi na entrada ou na saída e também verifica se teve apoio",
  "Diz se o acidente foi finalizado, cancelado, se é uma duplicidade, se esta pendente, se teve uma equipe em deslocamento, se teve uma equipe local ou se estar em aberto",
  "Informa o nome dos bairros que aconteceu o acidente",
  "Informa o nome das ruas ou avenidas que aconteceu o acidente",
  "Informa o número do local da rua ou avenida que aconteceu o acidente",
  "É o detalhamento do endereço do acidente, informando também a rua ou avenida.",
  "É uma variável para facilita a localização do endereço",
  "Informa o endereço do cruzamento entre as ruas ou avenidas",
  "Informa o número do cruzamento entre as ruas ou avenidas",
  "Informa um complemento do endereço e também ponto de referência de onde aconteceu o acidente",
  "nome dos bairro que aconteceu os acidentes referente a cruzamento",
  "Informa o código do semáforo mais próximo que teve o acidente",
  "Informa o destino principal seguindo da via que teve o acidente",
  "Informa o tipo de colisão",
  "Informa os principais envolvidos no acidente",
  "Informa o total de automóvel envolvido no acidente",
  "Informa o total de moto envolvido no acidente",
  "Informa o total de ciclo motor (exemplo de mobilete, ciquentinhas, bicicleta motorizada) envolvido no acidente",
  "Informa o total de ciclistas envolvidos no acidente",
  "Informa o total de pedestre envolvidos no acidente",
  "Informa o total de ônibus envolvidos no acidente",
  "Informa o total de caminhões envolvidos no acidente",
  "Informa o total de viatura públicas envolvidos no acidente",
  "Informa o total de veículo não registrados envolvidos no acidente, como exemplo:  carroça.",
  "Informa o total de vítimas não fatais envolvidas no acidente",
  "Informa o total de vítimas fatais envolvidas no acidente",
  "Nome do local específico do acidente",
  "Diz o estado do tempo",
  "Diz o estado em que o semáforo existente está e quando não existe semáforo informa também",
  "Estado em que se encontra a sinalização local",
  "Estado condicional da via no momento do acidente",
  "Informa o estado de conservação em que a via se encontra no momento do acidente",
  "Informa se tem algo que possa sinalizar alguma segurança",
  "Informa o Código da placa de sinalização quando tem, caso não tenha informa não existe",
  "Informa a velocidade máxima da via",
  "Informa o tipo de mão da via como exemplo mão única, mão dupla.",
  "Informa o tipo da faixa que existe na 1º via",
  "Informa o tipo da faixa que existe na 2º via",
  "Informa o tipo da faixa que existe na 3º via"
)


df_campo <- data.frame("Campo" = Campo, "Tipo" = Tipo,
                       "Descricao" = Descricao,
                       stringsAsFactors = FALSE) 

library(knitr)
#kable(mtcars[1:5, ], caption = "A knitr kable.")

kable(df_campo, caption = "Explicação de todas as variáveis")

# Como não consegui rodar no R Markdown, criei esta imagem a seguir para poder explicar cada campo (variável).
```


## 3.3 Limpeza 

### 3.3.1 Limpeza dos Dados

<p style="text-align: justify;">
A limpeza dos dados neste projeto está sendo aprensentado de forma resumida para facilitar o entendimento do processo.
</p>

#### 3.3.1.1 Limpeza dos caracteres especiais

<p style="text-align: justify;">
Foi utilizado a biblioteca library(stringr) para que pudesse aplicar o comando str_replace_all para todo o dataset, onde o caracter especial será trocado pela letra com a pontuação correta. \n
Segue um exemplo:
</p>

```{r exemplo, echo=TRUE}
#exemplo:
# df_transito$tipo <- str_replace_all(df_transito$tipo, "Ã\u008d", "Í")
```


<br><center>***Limpeza dos caracteres especiais de todas as variáveis categoricas que necessitam passar pelo processo***<br></center>

<p style="text-align: justify;">
A interpretação do texto fica muito difícil devido a grande quantidade de caracteres especiais<br>
Segue apresentação das 4 primeiras linhas:
</p>

```{r limpeza_da_tabela, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
library(dplyr)
library(tidyr)
library(knitr)
kable(head(select(df_transito, natureza_acidente,tipo,descricao,situacao_placa)), 
      caption = "Dados antes de ser corrigido caracteres especiais")

```

```{r Processo_limpeza, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}

library(stringr)

#<br><center>***Processo de limpeza de todas as variáveis por meio do comando str_replace_all que é <br>utilizado para mudar os caractesres especiais por letras.***
#</center>


#Tratamento da substituição dos caractesres especiais o letras corretas de todos os campos que necessitam
df_transito$natureza_acidente <- str_replace_all(df_transito$natureza_acidente, "Ã\u008d", "Í")
df_transito$tipo <- str_replace_all(df_transito$tipo, "Ã\u008d", "Í")
df_transito$tipo <- str_replace_all(df_transito$tipo, "ÃƒO", "ÃO")

df_transito$descricao <- str_replace_all(df_transito$descricao, "Ã\u008d", "Í")
df_transito$descricao <- str_replace_all(df_transito$descricao, "Ã‡ÃƒO", "ÇÃO")
df_transito$descricao <- str_replace_all(df_transito$descricao, "ÃƒO", "ÃO")
df_transito$descricao <- str_replace_all(df_transito$descricao, "Ã”NIBUS", "ÔNIBUS")
df_transito$descricao <- str_replace_all(df_transito$descricao, "NÃ£o", "NÃO")
df_transito$descricao <- str_replace_all(df_transito$descricao, "Ã‡Ãƒ", "ÇÃ")

df_transito$complemento <- str_replace_all(df_transito$complemento, "NÃ£o", "NÃO")
df_transito$complemento <- str_replace_all(df_transito$complemento, "Ã‡ÃƒO", "ÇÃO")


df_transito$acidente_verificado <- str_replace_all(df_transito$acidente_verificado, "NÃ£o", "NÃO")

df_transito$situacao_semaforo <- str_replace_all(df_transito$situacao_semaforo, "NÃ£o", "NÃO")

df_transito$sinalizacao <- str_replace_all(df_transito$sinalizacao, "NÃ£o", "NÃO")
df_transito$sinalizacao <- str_replace_all(df_transito$sinalizacao, "IlegÃ­vel", "Inlegível")

df_transito$ponto_controle <- str_replace_all(df_transito$ponto_controle, "ÃƒO", "ÃO")
df_transito$ponto_controle <- str_replace_all(df_transito$ponto_controle, "NÃ£o", "NÃO")
df_transito$ponto_controle <- str_replace_all(df_transito$ponto_controle, "retenÃ§Ã£o", "retenção")

df_transito$situacao_placa <- str_replace_all(df_transito$situacao_placa, "ÃƒO", "ÃO")
df_transito$situacao_placa <- str_replace_all(df_transito$situacao_placa, "NÃ£o", "NÃO")
df_transito$situacao_placa <- str_replace_all(df_transito$situacao_placa, "hÃ¡", "há")
df_transito$situacao_placa <- str_replace_all(df_transito$situacao_placa, "Placas DÃª a preferÃªncia", "Placas da preferência")

df_transito$mao_direcao <- str_replace_all(df_transito$mao_direcao, "Ãšnica", "Única")

df_transito$divisao_via1 <- str_replace_all(df_transito$divisao_via1, "NÃ£o", "NÃO")
df_transito$divisao_via1 <- str_replace_all(df_transito$divisao_via1, "contÃ­nua", "contínua")

df_transito$divisao_via2 <- str_replace_all(df_transito$divisao_via2, "NÃ£o", "NÃO")
df_transito$divisao_via2 <- str_replace_all(df_transito$divisao_via2, "contÃ­nua", "contínua")

df_transito$bairro <- str_replace_all(df_transito$bairro, "JOSÃ‰", "JOSÉ")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã\u0081", "Á")

df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã‡", "Ç")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ãƒ", "Ã")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã“", "Ó")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã•", "Õ")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã‡Ãƒ", "ÇÃ")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã\u008d", "Í")
df_transito$bairro <- str_replace_all(df_transito$bairro, "Ã”", "Ô")


```


#### 3.3.1.2 Dados Limpos

Resultado de uma parte dos dados já com as letras e pontuação correta.

<center>***Realizar a verificação após limpeza de todos os textos nas variáveis***</center><br>

<p style="text-align: justify;">
Segue apresentação das 4 primeiras linhas limpas sem caracteres especiais e com a pontuação correta:
</p>

```{r tabela_LIMPA, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}

library(dplyr)
library(tidyr)
library(knitr)
kable(head(select(df_transito, natureza_acidente,tipo,descricao,situacao_placa)), 
      caption = "Dados corrigidos")




```


#### 3.3.1.3 Limpeza para construções de variáveis

<p style="text-align: justify;">
Também foi aplicada a limpeza para o tratamento de dados em outros pontos para a criação de gráficos por meio da bibliotecas: dplyr e tidyr. Que se encontra como resultado nos gráficos deste projeto.
</p>

#### 3.3.1.4 Limpeza para nuvem de palavra referente aos acidentes registrados em Recife no ano 2019

<p style="text-align: justify;">
Neste ponto foi realizado a escolha da variável descrição onde relata todas as ocorrências de acidente de trânsito e que pode contribuir para conseguir gerar a nuvem de palavras referente ao acidentes registrados em Recife 2019.
</p>

```{r limpeza_nuvem, echo=TRUE}

#coloca tudo em minúsculo: 

#corpus_relato <- tm_map(corpus_relato, content_transformer(tolower))

#Remove pontuação: 

#corpus_relato <- tm_map(corpus_relato, removePunctuation)

#Remove espaços extras em branco: 

#corpus_relato <- tm_map(corpus_relato, stripWhitespace)

#Remove números:

#corpus_relato <- tm_map(corpus_relato, removeNumbers)

#Remove palavras ruido(palavras sem significado): 

#corpus_relato <- tm_map(corpus_relato, removeWords, stopwords('portuguese'))

```


# 4. Estatísticas dos dados  {.tabset}

## 4.1 Variância

### 4.1.1 Cálculo da variância das vítimas fatais e não fatais

<center>
Formula da Variância de uma população, que será a base para o cálculo seguinte:
<br>
$\sigma ^2 = \frac{\sum_{i=1}^{n}(x_{i}-\mu )^2}{n-1}$</center>

```{r Latex-variancia, echo=TRUE}
#Código Latex da formula apresentada para a variância de uma População

#$\sigma ^2 = \frac{\sum_{i=1}^{n}(x_{i}-\mu )^2}{n-1}$

```

#### 4.1.1.1 A variância das vítimas não fatais

```{r var_nao_fatal, echo=TRUE}
# Variâncias das vítimas não fatais
var(df_transito$vitimas, na.rm=TRUE)
```


#### 4.1.1.2 A variância das vítimas fatais

```{r var_fatal, echo=TRUE}
# Variâncias das vítimas fatais
var(df_transito$vitimasfatais, na.rm=TRUE)
```


## 4.2 Desvio Padrão

### 4.2.1 Cálculo do Desvio Padrão 

<center>
Formula do desvio padrão da população, que será a base para o cálculo seguinte:
<br>
$\sigma = \frac{\sqrt{\sum_{i=1}^{n}(x_{i}-\mu)^2}}{n-1}$</center>

```{r Latex-desvio_padrao, echo=TRUE}
#Código Latex da formula apresentada do desvio padrão da População

#$\sigma = \frac{\sqrt{\sum_{i=1}^{n}(x_{i}-\mu)^2}}{n-1}$

```

#### 4.2.1.1 Cálculo do Desvio Padrão da população em conformidade com o dataset em Recife no ano 2019 referente as vítimas fatais e não fatais em relação as médias.

```{r desvio_padrao_recife, echo=TRUE}

# Variâncias das vítimas não fatais
var(df_transito$vitimas, na.rm=TRUE)

# Desvio Padrão das vítimas não fatais
sd(df_transito$vitimas, na.rm=TRUE)

# A Média das vítimas não fatais
mean(df_transito$vitimas, na.rm=TRUE)

#Intervado do desvio padrão das Vítimas não Fatais em relação a média
cat("[",mean(df_transito$vitimas, na.rm=TRUE)-
      sd(df_transito$vitimas, na.rm=TRUE),"-",
    mean(df_transito$vitimas, na.rm=TRUE)+
      sd(df_transito$vitimas, na.rm=TRUE),"]")



# Variâncias das vítimas fatais
var(df_transito$vitimasfatais, na.rm=TRUE)

# Desvio Padrão das vítimas fatais
sd(df_transito$vitimasfatais, na.rm=TRUE)

# A Média e Mediana das vítimas fatais
mean(df_transito$vitimasfatais, na.rm=TRUE)

#Intervado do desvio padrão das Vítimas Fatais em relação a média
cat("[",mean(df_transito$vitimasfatais, na.rm=TRUE)-
      sd(df_transito$vitimasfatais, na.rm=TRUE),"-",
    mean(df_transito$vitimasfatais, na.rm=TRUE)+
      sd(df_transito$vitimasfatais, na.rm=TRUE),"]")



```

## 4.3 Amplitude

### 4.3.1 Cálculo da Amplitude

<p style="text-align: justify;">
Amplitude referente as vítimas fatais e não fatais em Recife no ano 2019 envolvidas em acidente de transito
</p>

```{r amplitude, echo=TRUE}

#Qual é a Amplitude das vítimas não fatais no transito
amplitude_vitimas <- max(df_transito$vitimas, na.rm=TRUE) - min(df_transito$vitimas, na.rm=TRUE)
amplitude_vitimas


#Qual é a Amplitude das vítimas fatais no transito
amplitude_vitimasfatais <- max(df_transito$vitimasfatais, na.rm=TRUE) - min(df_transito$vitimasfatais, na.rm=TRUE)
amplitude_vitimasfatais
```

## 4.4 Mediana

### 4.4.1 Cálculo da Mediana

<p style="text-align: justify;">
Mediana referente as vítimas fatais e não fatais em Recife no ano 2019 envolvidas em acidente de transito
</p>

```{r Mediana, echo=TRUE}
# A Mediana das vítimas não fatais
median(df_transito$vitimas, na.rm=TRUE)

# A Mediana e Mediana das vítimas fatais
median(df_transito$vitimasfatais, na.rm=TRUE)
```

## 4.5 Moda

### 4.5.1 Cálculo da Moda

Moda da Maior velocidade percorrida no transito de Recife no ano de 2019

```{r Moda, echo=TRUE}
#Moda da Velocidade Máxima.
names(table(df_transito$velocidade_max_via))[table(df_transito$velocidade_max_via)==
                                max(table(df_transito$velocidade_max_via))]	

```

## 4.6 Quartis

### 4.6.1 Cálculo do Quartis

Quartis referente as vítimas fatais e não fatais em Recife no ano 2019 envolvidas em acidente de transito

```{r Quartis, echo=TRUE}

# Quartis das vítimas não fatais
summary(df_transito$vitimas, na.rm=TRUE)

# Quartis das vítimas fatais
summary(df_transito$vitimasfatais, na.rm=TRUE)
```

### 4.6.2 Segue a situação dos semáforos na cidade de Recife com relação a quantidade de acidentes ocasionado por automóvel.

```{r boxplot_semaforo1,  echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}

library(dplyr)
library(tidyr)

df_box <- df_transito%>%select(auto,situacao_semaforo)

df_box <- df_box %>% drop_na()

```


```{r boxplot_semaforo2, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}

boxplot(auto ~ situacao_semaforo , data=df_box,
        xlab = "situacao_semaforo",
        ylab = "auto", 
        main = "Situação dos semáforos em Recife referente a acidentes com Automóveis", 
        col = rainbow(5),
        outline=FALSE)
```


## 4.7 Amostra

### 4.7.1 Cálculo de uma Amostra

<p style="text-align: justify;">
Para calcular o tamanho da amostra, a média das vítimas sem morte em acidente de transito registrado na da população de Recife no ano 2019 com `r sum(df_transito$vitimas, na.rm=TRUE)` ocorrências de vítimas. Tendo o desvio-padrão é de  `r sd(df_transito$vitimas, na.rm=TRUE)`  e admitindo-se um nível de confiança de 99% e um erro amostral de 1 vítima.
</p>

```{r amostra, echo=TRUE}
cat("O valor do Desvio Padrão é: ",sd(df_transito$vitimas, na.rm=TRUE))
cat("O total de vítimas sem morte são: ", sum(df_transito$vitimas, na.rm=TRUE))


#Cálculo para esta amostra:
dp<-sd(df_transito$vitimas, na.rm=TRUE)
total <-sum(df_transito$vitimas, na.rm=TRUE)
erro <-1
nc<-(1-0.99)/2
amostra <-(qnorm(nc, lower.tail= F)^2*dp^2*total)/ 
    ((erro^2*(total-1))+
    (qnorm(nc, lower.tail= F)^2*dp^2)) 
cat("O total da Amostra é",amostra)
```

## 4.8 Teorema Central do Limite

### 4.8.1 Cálculo do Teorema Central do Limite

<p style="text-align: justify;">
O Teorema diz que quando o tamanho amostral é suficientemente grande, a distribuição das médias é uma distribuição aproximadamente normal.
Ele permite a aplicação destes procedimentos úteis a populações que são fortemente não-normais.
\n
Diante desta situação foi realizado a média de uma amostragem de 200 vítimas com um tamanho de 60, chegando ao seguinte resultado.
</p>

```{r TCL, echo=T}
valor <- df_transito$vitimas
valor<-valor[!is.na(valor)]
n <- 200
TamMedia <- 60
Media <- rep(NA, n)
for(i in 1:n){
  MinhaAmostra <- sample(valor, size = TamMedia)
  Media[i]<-mean(MinhaAmostra)
}
hist(Media, 
     density = 10, 
     probability = T, 
     main="Teorema Central do Limite \n 
     Histograma de Vítimas sem Morte")
lines(density(Media), col=2)

```



# 5. Nuvem e Sentimentos  {.tabset}

## 5.1 Nuvem

### 5.1.1 Gráfico de barras dos termos mais frequentes

<p style="text-align: justify;">
Nas ocorrências dos acidentes de trânsito em Recife no ano de 2019 tem algumas palavras que mais aparece e que deve ser tratado com bastante atenção para poder tomar alguma ação, como exemplo: \n
</p>

<center>***Gráfico de barras dos termos mais frequentes***</center>

```{r nuvem_relato, echo=FALSE}

#####################################################################################
#Nuvem - Referente as Descrições relatadas nos acidentes
#####################################################################################
 

#install.packages("readr")
#install.packages("tm")
#install.packages("wordcloud")
#install.packages("tm.lexicon.GeneralInquirer", repos="http://datacube.wu.ac.at", type="source")
#install.packages("SnowballC")

library(tm.lexicon.GeneralInquirer)
library(tm)
library(wordcloud)
library(readr) # Pra carregar deve usar esta função
library(tm)
library(SnowballC)
library(dplyr)
library(tidyr)



#getwd()
#setwd("C:/mestrado_UFRPE_Informatica_Aplicada_Neiton/Computacao_para_Analise_de_Dados/Atividades/Projeto Neiton")

#Criando uma variável para receber toda a descrição
relato <- df_transito%>%select(descricao)
#Retirando todos os 'NA'
relato <- relato %>% drop_na()  


#Colapsando todo texto em uma posição para juntar tudo em um único campo
relato <- paste(relato, collapse = " ")

#Para processar um texto usando o pacote tm, é necessário converter esse dados
#em um formato chamado corpus, que pode ser processado pelo pacote tm.

vs <- VectorSource(relato)
corpus_relato <- Corpus(vs)

#Verificando o arquivo corpus gerado por meio de uma inspeção do texto

#inspect(corpus_relato)

#------------------------------------------------------------------------------
#Limpeza
#------------------------------------------------------------------------------

#coloca tudo em minúsculo
corpus_relato <- tm_map(corpus_relato, content_transformer(tolower))

#Remove pontuação
corpus_relato <- tm_map(corpus_relato, removePunctuation)

#Remove espaços extras em branco
corpus_relato <- tm_map(corpus_relato, stripWhitespace)

#Remove números
corpus_relato <- tm_map(corpus_relato, removeNumbers)

#Remove palavras ruido(palavras sem significado como exemplo: para, você...)
corpus_relato <- tm_map(corpus_relato, removeWords, stopwords('portuguese'))

#Para entender quais são as palavras ruidos é só executar o comando abaixo:

#stopwords('portuguese')

#Verificando o arquivo corpus após a limpeza

#inspect(corpus_relato)

#Converte para o formato de uma matriz
tdm_relato <- as.matrix(TermDocumentMatrix(corpus_relato))

#fornece as frequências ordenadas de cada palavra de acordo com frequência na Ordem Alfabética

fre_relato <- sort(rowSums(tdm_relato))

# Ordem das palavras que mais repetiram
fre_relato <- sort(rowSums(tdm_relato), decreasing = TRUE)

#Escolhe um subconjunto dos dados
aux_relato <- subset(fre_relato, fre_relato>2)
```

```{r grafico_sentimento, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
#plota o gráfico de barras dos termos mais frequentes
barplot(aux_relato, las=2, col = rainbow(10))

```

<p style="text-align: justify;">
Diante desta evidência é possível ver que a palavra mais relata é colição, e que precisar ser tomada uma ação para evitar que este problema continue a acontecer. \n
Por isso neste projeto propõem algumas ações preventivas para salva vítimas de acidentes de trânsito.
</p>

### 5.1.2 Nuvem das palavras que mais aparece o campo descrição relatado nas ocorrências

<p style="text-align: justify;">
Nuvem das palavras quem mais foram relatalas nas ocorrências de acidente de trânsido.
</p>

<center>***Nuvem das palavras que mais aparece o campo descrição relatado nas ocorrências***</center>

```{r nuvem, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
#-----------------------------------
#NUVEM DE PALAVRAS
#-----------------------------------
#corpus_relato: O vetor de palavras a ser plotado
#min.freq: Palavras com frequência menor que essa não serão mostradas
#mas.words: Máximo de palavrvas a serem plotadas
#random.order: Plota as palavras em ordem randômicas.
#False significa que são plotadas as palavras mais frequentes.
#rot.per: Quantidade de rotação para aplicar a cada palavra(0-1)
#colors:cores a serem usadas.

wordcloud(corpus_relato, 
          min.freq = 1, 
          max.words = 100, 
          random.order = FALSE,
          rot.per = 0.35, 
          colors = brewer.pal(8, "Dark2"))

```

<p style="text-align: justify;">
É muito importante que seja tomada uma ação para evitar que este problema continue acontecendo. 
</p>

## 5.2 Sentimentos

### 5.2.1 Sentimentos do Trânsito em Recife utilizando a \#transitoRecife

Sentimentos do Trânsito em Recife utilizando a #transitoRecife

```{r sentimentos, echo=FALSE}

###########################################################
# Sentimentos - TRANSITO EM RECIFE NO Twitter
############################################################

#Mineração de dados (Parte 3) - Análise de Sentimentos Twitter

#getwd()
#setwd("C:/mestrado_UFRPE_Informatica_Aplicada_Neiton/Computacao_para_Analise_de_Dados/PROVA_2VA")

#install.packages("twitteR")
#install.packages("syuzhet")

library(twitteR)
library(tm)
library(syuzhet)

#chaves de Autorização de Neiton Twitter
consumer_key <- 'cXm1PvQJhUMa7xeKe7dHvjKuA'
consumer_secret <- 'TYVw27d8yI7nJMSdH8A0JdXJ5qfOpDN3DdqaZ0HYhairjY8Z7X'
access_token <- '1281007322748399617-WHLV6IXPbjnKHixvMyEFfBHG7g5X3P'
access_secret <- 'OOojblZAQmTDo9MCwzxUkcHAtK9G5eTqmRWA7BkKJEenJ'

print("Os dados foram autorizado pelo Twitter?")

cat("Então ok",setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret))

#Consultando o Twitter
tweets_sentimentos <- searchTwitter("#transitoRecife", n=500, lang="pt")

#Convertendo os twittes para o formato de Data Frame.
tweets_sentimentos <- twListToDF(tweets_sentimentos)

#Acessando apenas os Textos
tweets_sentimentos <- tweets_sentimentos$text

#Pontuando os tweets
df_Pontuacao <- get_nrc_sentiment(tweets_sentimentos)

#Esse pacote (get_nrc_sentiment) quebra as emoções em 8 tipos diferentes, como exemplo:
#(raiva, antecipação, nojo, medo, alegria, tristeza, surpresa, confiança)
#e os sentimentos em dois tipos (negativo e positivo)
#Sendo que as primeiras são as emoções e as duas ultimas são os sentimentos no caso positivo e negativo
#É utilizado processamento de linguagem natural


#View(df_Pontuacao)

#Ver as 06 primeiras linhas
#head(df_Pontuacao)
```

```{r SENTIMENTO_tWItter, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
#Plotando os sentimentos
barplot(
  colSums(df_Pontuacao), 
  las=2, col=rainbow(10),
   ylab="Contagem", 
  main="Sentimentos com relação \n 
  ao Trânsito em Recife \n no Twitter"
  )

```

### 5.2.2 Tradução dos nomes das colunas do gráfico sobre sentimentos

```{r Traducao, echo=FALSE}
#Tradução grafico sentimento

ingles <- c("anger",
            "anticipation",
            "disgust",
            "fear",
            "joy",
            "sadness",
            "surprise",
            "trust",
            "negative",
            "positive"
)

port <- c("raiva",
          "antecipação",
          "nojo",
          "medo",
          "alegria",
          "tristeza",
          "surpresa",
          "Confiar em",
          "negativo",
          "positivo"
)

sent <- data.frame("Inglês" = ingles, "Português" = port)

library(knitr)
#Apresentação das 03 primeiras linhas do dataset
kable(sent, caption = "Tradução")

```

<p style="text-align: justify;">
Conforme os sentimentos aprensentados pelo Twitter, é possível dizer que o trânsito na cidade de Recife está com um sentimento bom e bastante positivo.
</p>

# 6.Análise Exploratória dos dados {.tabset}

## 6.1 Análise dos transportes

### 6.1.1 Análise dos transportes envolvidos no acidente de trânsito tem Recife 2019

<p style="text-align: justify;">
Nesta seção será abordada técnicas data science buscando alguma informação que possa evitar acidentes de trânsito:
</p>

```{r grafico, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
#Gráfico de Barras

Auto <- sum(df_transito$auto, na.rm=TRUE)
Moto <- sum(df_transito$moto, na.rm=TRUE)
ciclom <- sum(df_transito$ciclom, na.rm=TRUE)
ciclista <- sum(df_transito$ciclista, na.rm=TRUE)
pedestre <- sum(df_transito$pedestre, na.rm=TRUE)
onibus <- sum(df_transito$onibus, na.rm=TRUE)
caminhao <- sum(df_transito$caminhao, na.rm=TRUE)
viatura <- sum(df_transito$viatura, na.rm=TRUE)
outros <- sum(df_transito$outros, na.rm=TRUE)

barra <- c(Auto,Moto,onibus,caminhao,pedestre,ciclista,outros,viatura,ciclom)
nomes <- c("Auto","Moto","Ônibus","Caminhao","Pedestre","Ciclista","Outros","Viatura","Ciclom")

```

```{r grafico_acidentes_2019, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}

xx <- barplot(barra,
        width = 0.5,
        legend.text = nomes,
        beside = TRUE,
        xlim = c(0, 9), ylim = c(0, 20000),
        axes = TRUE, axisnames = TRUE,
        angle = 45,
       # horiz = TRUE,
        main = "Acidentes Ocorritos em Recife 2019",
        ylab = "Total de Acidentes",
        xlab = "Transportes",
        #names.arg = nomes,
        col = rainbow(9))
## Add text at top of bars
text(x = xx, y = barra, label = barra, pos = 3, cex = 0.8, col = "blue")
## Add x-axis labels 
axis(1, at=xx, labels=nomes, tick=FALSE, las=2, line=-0.5, cex.axis=1)


```


```{r tabela_se, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
df_barra <- data.frame("Transporte"=nomes,"Acidentes"=barra)
library(dplyr)
library(tidyr)
library(knitr)
kable(df_barra, caption = "Total de acidentes de cada transporte")


```

<p style="text-align: justify;">
O interessante é que muitas pessoas inclusive o autor normalmente pensa que a maior quantidade de acidentes em transito envolvem motos, mas com base nesta evidência foi possível ver que não é verdade
</p>

### 6.1.2 Dispersão entre os dois maiores tipos de acidentes de trânsito.

```{r codgo_dispercao, echo=FALSE}
df_disp <- df_transito%>%select(natureza_acidente,
                                auto,moto)

df_disp <- df_disp %>% drop_na()
```


```{r dispersao, echo=TRUE}

plot(df_disp$moto~df_disp$auto, 
     main = "Dispersão dos acidentes entre \n Automóveis e Motos",
     col = c("blue","green","red"),
     pch=18,
     cex=2,
     ylab = "Acidentes com Motos",
     xlab = "Acidentes com Automóveis")
legend("topright", 
       pch = 18,
       col = c("blue","green","red"), 
       legend = unique(df_disp$natureza_acidente))

```



## 6.2 Bairros com mais acidentes

### 6.2.1 O Bairro de Boa Viagem é o que mais tem acidente de trânsito

<p style="text-align: justify;">
Bairros que tirevam mais acidentes com automóveis (auto) em Recife ano 2019 \n
Vou preparar a massa de dados para descobrir quais são os bairros que mais tem acidentes de transito em Recife<br>
</p>

```{r Grafico_Pizza, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
#Bairros que tirevam mais acidentes de Carro em Recife ano 2019

Grafico_pizza <- df_transito %>%
  group_by(bairro) %>%
  filter(auto > 2) %>%
  summarise(
    acidende_Carro = sum(auto),
    Bairro = bairro
  ) 

Grafico_pizza <- Grafico_pizza[,1:2]

#Removendo duplicidade:
index <-  which(duplicated(Grafico_pizza))
Grafico_pizza<-Grafico_pizza[-index, ]

#which(duplicated(Grafico_pizza))

Grafico_pizza <- filter(Grafico_pizza, acidende_Carro>60)

#View(Grafico_pizza)
```


```{r grafico_1, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
x <- Grafico_pizza$acidende_Carro
labels <- Grafico_pizza$bairro
 pct <- round(x/sum(x)*100)
 lbls <- paste(labels, pct)
 lbls <- paste(lbls,"%",sep="")
 pie(x,labels=lbls, main="Bairros que tirevam mais acidentes com automóveis",col=rainbow(6))
```


```{r TABELA_1, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
 #Os seis bairros que tiveram mais acidentes
 #head(Grafico_pizza)
 
 library(dplyr)
library(tidyr)
library(knitr)
kable(Grafico_pizza, caption = "Bairros com mais acidentes de trânsitos")

```

 
## 6.3 Semáforos

### 6.3.1 Situação dos Semáforos no bairro de Boa Viagem

<p style="text-align: justify;">
Realizar uma análise do estado em que se encontra os semáforos no bairro que teve maior ocorrência de acidentes de trânsito.
</p>

```{r semaforo, echo=FALSE}

library(dplyr)
library(tidyr)
library(knitr)

boa_viagem <- df_transito%>%
  filter(bairro == "BOA VIAGEM")%>%
  select(bairro, situacao_semaforo)

#estado <- table(boa_viagem$situacao_semaforo)

quantidade_semaforo <- c(689,473,5,4,1)
nomes_semaforo <- c("NÃO existe","Sem defeito","Com defeito","Intermitente","Desligado")

```

```{r grafico_3, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}

xx <- barplot(quantidade_semaforo,
              width = 0.5,
              legend.text = nomes_semaforo,
              beside = TRUE,
              xlim = c(0, 5), ylim = c(0, 800),
              axes = TRUE, axisnames = TRUE,
              angle = 45,
              #horiz = TRUE,
              main = "Situação dos Semáforos \n no bairro Boa Viagem",
              ylab = "Total de Acidentes",
              xlab = "semafóro",
              #names.arg = nomes,
              col = rainbow(5))
## Add text at top of bars
text(x = xx, y = quantidade_semaforo, label = quantidade_semaforo, pos = 3, cex = 0.8, col = "blue")
## Add x-axis labels 
axis(1, at=xx, labels=nomes_semaforo, tick=FALSE, las=2, line=-0.5, cex.axis=0.7)

```


```{r TABELA_2, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}

kable(table(boa_viagem$situacao_semaforo), caption = "Estado em que os semafóros se encontra no bairro de Boa Viagem")


```


## 6.4 Ação Preventiva

### 6.4.1 Instalação de semafóros e cinco lugares em Boa Viagem

<p style="text-align: justify;">
Provável ação preventiva para evitar novos acidentes \n

Instalar mais alguns semáforos nas ruas ou avenidas que tem mais de 30 registros de acidentes.</p>


```{r novo_semaforo, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}

#Estou criando este data frame para poder filtrar as principais ruas/avenidas com a situação de cada semáforo
logradouro <- df_transito%>%
  filter(bairro == "BOA VIAGEM", situacao_semaforo == "NÃO existe")%>%
  select(endereco, numero)

#exemplo de total de acidentes em 6 bairros:
#head(table(logradouro$endereco))

#Separando as ruas com mais de 30 acidentes

rua <- c("a-AV BOA VIAGEM","b-AV CONSELHEIRO AGUIAR","c-AV ENGENHEIRO DOMINGOS FERREIRA",
         "d-RUA RIBEIRO DE BRITO","e-RUA VISCONDE DE JEQUITINHONHA")

n1 <- sum(str_count(logradouro$endereco,"AV BOA VIAGEM"), na.rm=TRUE)
n2 <- sum(str_count(logradouro$endereco,"AV CONSELHEIRO AGUIAR"), na.rm=TRUE)
n3 <- sum(str_count(logradouro$endereco,"AV ENGENHEIRO DOMINGOS FERREIRA"), na.rm=TRUE)
n4 <- sum(str_count(logradouro$endereco,"RUA RIBEIRO DE BRITO"), na.rm=TRUE)
n5 <- sum(str_count(logradouro$endereco,"RUA VISCONDE DE JEQUITINHONHA"), na.rm=TRUE)

total <- c(n1,n2, n3, n4, n5)

vetor <- c("a","b","c","d","e")

```


```{r grafico_4, echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
barplot(total,
        main = "Ruas ou Avenidas com mais de 30 acidentes em Boa Viagem 2019",
        ylab = "Rua ou Avenida",
        xlab = "Total Acidentes",
        names.arg = vetor, 
        col = rainbow(5),
        xjust = 0.5 ,
        horiz = T
        )
legend("topright",
       pch = c(15,15,15,15,15),
       col = rainbow(5), 
       text.width = 30,
      legend=rua)
```


### 6.4.2 Tabela com os totais de acidentes em Boa Viagem

<p style="text-align: justify;">
A Provável ação preventiva pode ser tomada, da seguinte forma, instalar 05 semáforos nos cinco principais logradouros no bairro de Boa Viagem em Recife.<br>
Pois como evidência no total de acidentes somente nestas cinco vias são: `r sum(total)`. 
</p>

```{r acao, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
#Tabela das vias com sua quantidade de acidentes:
tabela <- data.frame(localizacao <- rua, quantidade <- total)
#head(tabela)

library(dplyr)
library(tidyr)
library(knitr)

kable(tabela, caption = "Estado em que os semafóros se encontra no bairro de Boa Viagem")

```

### 6.4.3 A Ação pode salvar vidas de forma preventiva

Chegando a este total de acidentes que pode ser evitado

```{r SOMA, echo=TRUE}

sum(total)

```


# 7.Conclusão  {.tabset}

## 7.1 Ação Preventiva

### 7.1.1 Instalação de semáforos de cinco vias que tem mais de 30 acidentes no bairro de Boa Viagem

<p style="text-align: justify;">
Foi evidenciado com base nos dados que cinco semáforos sendo um para cada rua ou avenida menicionado no item 6.4.1 no bairro de Boa viagem podendo evitar vários acidentes. <br></p>


<p style="text-align: justify;">
Na análise investigativa pra entender as prováveis causas de acidentes nos principais bairros, foi por meio um levantamento pra saber o bairro que mais têm ocorrências e foi constatado que no bairro de Boa Viagem, no qual existem algumas vias que não tem semáforos registrados no item 6.3.1 e assim pode chegar numa provável conclusão de um tratamento de uma ação preventiva para evitar mais vítimas de acidentes de trânsito. 
<br></p>

<p style="text-align: justify;">
O insights que levou o autor a estas intuições foi buscar entender como evitar que um acidente possa acontecer, e como normalmente a maioria dos condutores param os carros por meio de semáforos e na massa de dados foi possível ver que existe uma grande quantidade de acidentes em lugares que não têm semáforos, logo foi feito uma investigação para saber quais são as vias que mais têm acidentes e como pode evitar. Chegando a uma provável solução de cinco semáforos nestas vias aprensentadas no item 6.4.1.
</p>


## 7.2 Clientes

### 7.2.1 Potênciais Clientes

<p style="text-align: justify;">
As implicações para aderir um potêncial cliente público ou privado pode ser baseado no valor que o governo pode pagar a cada idenização no DPVAT onde os valores das indenizações podem chegar até R$ 13.500,00 por cada acidente dependendo da análise médica.
<br>
link: [Tabela de Idenização no DPVAT](http://www.susep.gov.br/setores-susep/cgpro/dpvat)
<br>
A Provável ação preventiva que é instalar semáforos para evitar ocorrências de idenizações por meio do DPVAT e ainda salvar vidas.
</p>

#### 7.2.1.1 Vias com mais de 30 acidentes de trânsito cada

```{r cliente_RUA, echo=FALSE, warning=FALSE, message=FALSE, error=FALSE}
#Nestas principais vias que ocorreu acidentes:
#head(rua)
#Tabela das vias com sua quantidade de acidentes:
tabela <- data.frame(localizacao <- rua, quantidade <- total)
#head(tabela)

library(dplyr)
library(tidyr)
library(knitr)

kable(tabela, caption = "Estado em que os semafóros se encontra no bairro de Boa Viagem")

```

#### 7.2.1.2 Total de vítimas em apenas nestas cinto vias

```{r cliente_SOMA, echo=TRUE}
#com o total de acidentes:
sum(total)

```

#### 7.2.1.3 Tabela de Indenização de trânsito

<p style="text-align: justify;">
Os valores de indenização por cobertura são os constantes da tabela abaixo, valores estes fixados na Lei 6.194/74, por meio da Lei 11.482, de 31/05/2007:
</p>

```{r tabela_indenizacao, echo=FALSE}

causa <- c("Morte",	
           "Invalidez Permanente (1)",
           "Reembolso de Despesas Médicas e Hospitalares (DAMS) (2)")

indenizacao <- c("R$ 13.500,00",
                 "até R$ 13.500,00",
                 "até R$ 2.700,00")

tabela_indenizacao <- data.frame("Dano do Acidente" = causa, "Indenização" = indenizacao)

library(dplyr)
library(tidyr)
library(knitr)

kable(tabela_indenizacao, caption = "Valores de indenização do DPVAT referente a acidente de trânsito")

```


<p style="text-align: justify;">
É muito importante entender que cada acidente de trânsito registrado leva a uma indenização.
</p>


#### 7.2.1.4 Ilustração das idenizações do DPVAT disponível por meio do jornal Gazeta do Povo


![Gazeta do Povo: Tabela do DPVAT](https://media.gazetadopovo.com.br/2009/05/9d682633db7acba6f2dc1f63e069b204-gpLarge.jpg)



### 7.2.2 limitação do Projeto

<p style="text-align: justify;">
A limitação desta análise é que não foi realizado a mesma para todos os bairros da cidade de Recife que também acontece acidentes de trânsito.
</p>

## 7.3 Agradecimentos

### 7.3.1 Agradecimentos do Autor

<p style="text-align: justify;">
E claro que quem mais contribuiu para o meu conhecimento apesar de tanta dificuldade para conseguie passar por cada obstaculo de atividade, foi o professor @andrade2009methodology. Pois foi o professor que mais cobrou e por isso estou podendo apresentar este trabalho desta forma.
<br>
O desenvolvimento desste projeto foi bastante importante o conhecimento referente a R Markdown seguinte @xie2018r, como também o layout deste projeto pode recebe os créditos @white2012package em parceria com @lonne2014development e também @coghlan2015little que puderam contribuir com o conhecimento referente a este relatório.
</p>


# 8.Apresentação do Vídeo e Projeto no GitHub  {.tabset}

## 8.1 Apresentação YouTube

### 8.1.1 Link direto para o YouTube

Segue o link do vídeo que fiz para apresentar o projeto. [Vídeo da apresentação](https://www.youtube.com/watch?v=PaLfACIAbbs)

### 8.1.2 Link para cópiar e colar na URL para chegar no YouTube

Caso o link não funcione. Pode copiar o link aqui:  https://www.youtube.com/watch?v=PaLfACIAbbs
<br>

## 8.2 Projeto no GitHub

<p style="text-align: justify;">
A necessidade de fazer esta guia sobre o GitHub é porque, muitos links que são direcionado para fora do RPubs não funcionam quando estão publicados no RPubs, por isso o autor teve a necessidade de também publicar no GitHub.
</p>

### 8.2.1 Link direto para o GitHub

<p style="text-align: justify;">
Segue o link deste projeto no GitHub como prova que todos os links estão funcionando: [Aperte aqui](https://neitoncarvalho.github.io/Projeto_Neiton/)
</p>

### 8.2.2 Link para cópiar e colar na URL para chegar no GitHub

Caso este link não funcione, pode ser copiado o seguinte link: 
https://neitoncarvalho.github.io/Projeto_Neiton/


# 9. Referências  


<!-- Titulo 1: # header 1 -->
<!-- Titulo 2: ## header 2 -->
<!-- Titulo 3: ### header 3 -->
<!-- Titulo 4: #### header 4 -->
<!-- seções com Abas: {.tabset} -->
<!-- Texto Negrito: **bold** -->
<!-- Texto Itálico: *italics* -->
<!-- Texto Código: `code` -->
<!-- Incluir um link: [Rural](www.ufrpe.br) -->

